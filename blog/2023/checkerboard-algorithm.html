<!DOCTYPE HTML>
<!--
	Landed by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>The Checkerboard Algorithm Explained. | Kherzie Andal</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="/assets/css/main.css" />
		<noscript><link rel="stylesheet" href="/assets/css/noscript.css" /></noscript>
	</head>
	<style>
		.column {
		float: left;
		width: 40%;
		padding: 1em;
		margin-left: auto;
		margin-right: auto;
		}

		/* Clear floats after image containers */
		.row::after {
		content: "";
		clear: both;
		display: table;
		}

		#caption{
			text-align: center;
		}

		img.center {
			display:block; 
			margin-left: auto; 
			margin-right: auto; 
			width: 30%;
		}

		p.center{
			text-align: center;
		}

		a.center{
			text-align: center;
		}

		.no_space {
			margin-bottom: 0.25em;
		}

		ol.no_space{
			margin-top: 0;
			margin-bottom: 0;
		}

		li.shuffle_left{
			margin-left: 2em;
			padding: 0.25em;
		}

		pre{
			margin-bottom: 0.25em;
		}
	</style>

	<script type="text/javascript" id="MathJax-script" async
		src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
	</script>

	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<header id="header">
					<h1 id="logo"><a href="/index.html">Kherzie Andal</a></h1>
					<nav id="nav">
						<ul>
							<li><a href="/index.html">Home</a></li>
							<li>
								<a href="/blog.html">Blog</a>
							</li>
							<li><a href="/research.html">Research</a></li>
						</ul>
					</nav>
				</header>

			<!-- Main -->
				<div id="main" class="wrapper style1">
					<div class="container">
						<header class="major">
							<h2>The Checkerboard Metropolis Algorithm Explained.</h2>
						</header>

						<!-- Text -->
							<section>
								<header>
									<p>Date created: July 28, 2023</p>
									<p>Last Updated: August 10, 2023</p>
								</header>
								<p>In statistical physics, the Ising model assumes that the physical system of magnets can be mathematically represented by a lattice arrangement of molecules. In this model, every molecule possesses a "spin", which can align either upwards or downwards corresponding to the external magnetic field's direction. We will represent these spins +1 and -1 respectively as shown in the figure below (others represent the alignment as 0 and 1).
								</p>
								<div>
									<img src="/blog/2023/images/ising_10_spins.jpg" alt="10x10 2D Ising model with random spins" class="center">
									<p class="center">10x10 2D Ising model with random spins</p>
								</div>
								<p>
								Phase transition can be identified using the model as a simplified representation of reality. Phase transition often happens when the system moves from one zone to another and the temperature changes. The most common phase transition seen is between states of matter. For instance, from solid to liquid (ice to water). Similar to the phase changes in the states of matter, there is a phase transition in the Ising model as well. The model displays paramagnetic-ferromagnetic phase transition. Ernst Ising solved the 1D Ising model, although it did not indicate a phase transition at a positive temperature. Lars Onsager, on the other hand, was able to demonstrate phase transition \((T_c = 2.269)\) for the 2D Ising model.<br><br>
								One way to study the critical phenomena — the behavior of the system near a critical point where a phase transition occurs — of the Ising model is through Monte Carlo (MC) simulations. In a Monte Carlo simulation, instead of solving a problem analytically, random numbers are generated to simulate the behavior of a system or process. These random numbers are used as inputs to the mathematical model representing the problem, and the model's response is analyzed statistically.
								</p>
								<div class="no_space">
									<p class="no_space">A type of Monte Carlo Simulation is the Metropolis Algorithm. The pseudocode is as follows:</p>
									<hr class="no_space">
									<ol class="no_space">
										<li class="shuffle_left">Choose an initial state \(S(0)=(S_1,\ldots,S_N)\)</li>
										<li class="shuffle_left">Choose an \(i\) randomly or sequentially and calculate \(\Delta E=-2S_ih_i\)</li>
										<li class="shuffle_left">If \(\Delta E\geq 0\), then flip the spin, \(S_i \to -S_i\). If \(\Delta E < 0 \), draw a uniformly distributed random number \(r\in[0,1]\). If \(r < e^{\Delta E / k_B T}\), flip the spin, \(S_i\to-S_i\), otherwise take the old configuration into account once more.</li>
										<li class="shuffle_left">Iterate 2 and 3.</li>
									</ol>
									<hr class="no_space">
								</div>

								<br>
								<p>An implementation in Python is shown below:</p>
								<pre><code>######### MODULES #############
import numpy as np
import matplotlib.pyplot as plt

######### VARIABLES #############
lattice_n = 16 # number of rows
lattice_m = lattice_n # number of columns
temp = 0.5 # temperature
eq_steps = 1000 # Equilibration steps
J=1 # Interaction constant
h=0 # External magnetic field

######### FUNCTIONS #############
def initial_state(N, M):   
	state = np.random.choice(np.array([-1,1]),size=(N,M))
	return state

def mc_move(lattice, inv_T):    
	'''Monte Carlo move using Metropolis algorithm '''
	n = lattice.shape[0]
	m = lattice.shape[1]
	for i in range(n):
		for j in range(m):
			# Periodicity for neighbors out of index
			ipp = (i + 1) if (i + 1) < n else 0
			jpp = (j + 1) if (j + 1) < m else 0
			inn = (i - 1) if (i - 1) >= 0 else (n - 1)
			jnn = (j - 1) if (j - 1) >= 0 else (m - 1)  
			
			# Calculate neighbors
			nb = lattice[ipp,j] + lattice[i,jpp] + lattice[inn,j] + lattice[i,jnn]
			
			# Compute energy difference
			spin =  lattice[i, j]
			deltaE = -2*spin*(J*nb + h)
			if deltaE >= 0:
				lattice[i, j] = -spin
			elif np.random.rand() < np.exp(deltaE*inv_T):
				lattice[i, j] = -spin
	return lattice

def plot_ising(lattice, colorbar=True):
	# plt.figure(figsize=(12, 9))
	plt.imshow(lattice, cmap='gray', vmin=-1, vmax=1) 
	if colorbar == True:
		plt.colorbar()

######### SIMULATION #############
inv_T = 1/temp # Inverse temperature

lattice = initial_state(lattice_n, lattice_m) # Initialize the lattice
initial_lattice = lattice.copy() # Copy lattice for the plotting

# Equilibration
for i in range(eq_steps):
	mc_move(lattice, inv_T)

# Plot the lattices
plot_ising(initial_lattice)
plt.show()
plot_ising(lattice)
plt.show()</code></pre><p class="center"><a href="#">Code Link</a></p>

								<p>When we try to animate the flipping of the Metropolis simulation, it is shown below (left figure).</p>

								<div class="row">
									<div class="column">
										<img src="/blog/2023/images/metropolis_16_0.5.gif" alt="Metropolis Algorithm" style="width:100%; height:100%;">
									</div>
									<div class="column">
										<img src="/blog/2023/images/checkerboard_16_0.5.gif" alt="Checkerboard Algorithm" style="width:100%; height:100%;">
									</div>
								</div>

								<div class="row">
									<div class="column">
										<p id="caption">Metropolis Algorithm</p>
									</div>
									<div class="column">
										<p id="caption">Checkerboard Algorithm</p>
									</div>
								</div>

								<p>The problem with the Metropolis algorithm is its performance — only a single spin is being flipped at a time. One way to strategize for the performance of the simulation is through parallel computing. Code can be run more quickly and efficiently with the aid of parallel computing. We could implement parallel computing using the multiple cores we have on our CPU. Although, a better option would be through the use of GPU as it allows faster computation. 
								</p>

								<p class="no_space">To implement parallel computing, we must consider the dependency of each spin — the complexity of parallel computing remains a challenge for every application of it as it requires careful consideration of dependencies between tasks. If we’re going to update all of the spins at once, it would raise such problems:</p>
								<ul class="no_space">
									<li class="shuffle_left">The neighboring spins for each iteration may differ, not allowing us to implement a random seed.</li>
									<li class="shuffle_left">The calculation of the properties of the model may have inconsistencies and fluctuations.</li>
								</ul>
								<p class="no_space">Thus, the checkerboard algorithm was created. It allows parallel spin updates exclusively within non-interacting domains. The pseudocode for the checkerboard algorithm is as follows:</p>
								<ol class="shuffle_left">
									<li class="shuffle_left">Populate an \(n\times m/2\) array of random values.</li>
									<li class="shuffle_left">Update spins on the lattice for the current color using the opposite-colored lattice spin values and the random value array.</li>
								</ol>
								<p>For the first step, example of an \(n\times m/2\) array is shown below. The image on the left is the array. When we convert it in the lattice, it would show the right image.</p>
								
								<div class="row">
									<div class="column">
										<img src="/blog/2023/images/checkerboard_half_lattice_black.png" alt="n by m over 2 array (black lattice). The numbers correspond to the indices." style="width:50%; display:block;  margin-left: auto; margin-right:auto;">
									</div>
									<div class="column">
										<img src="/blog/2023/images/checkerboard_lattice_black_only.png" alt="n by m over 2 array when represented as a black lattice." style="width:100%;">
									</div>
								</div>

								<div class="row">
									<div class="column">
										<p id="caption">\(n\times m/2\) array (black lattice). The numbers correspond to the indices.</p>
									</div>
									<div class="column">
										<p id="caption">\(n\times m/2\) array when represented as a black lattice.</p>
									</div>
								</div>
								This is also the case for the white lattice:
								<div class="row">
									<div class="column">
										<img src="/blog/2023/images/checkerboard_half_lattice_white.png" alt="n by m over 2 array (white lattice). The numbers correspond to the indices." style="width:50%; display:block;  margin-left: auto; margin-right:auto;">
									</div>
									<div class="column">
										<img src="/blog/2023/images/checkerboard_lattice_white_only.png" alt="n by m over 2 array when represented as a white lattice." style="width:100%;">
									</div>
								</div>
								<div class="row">
									<div class="column">
										<p id="caption">\(n\times m/2\) array (white lattice). The numbers correspond to the indices.</p>
									</div>
									<div class="column">
										<p id="caption">\(n\times m/2\) array when represented as a white lattice.</p>
									</div>
								</div>
								Combining the arrays would results to a checkerboard,
								<img src="/blog/2023//images/checkerboard_lattice.png" alt="" style="display: block; margin-left: auto; margin-right: auto; width: 40%;">

								For the second step, we’ll update the following with the random values. From the images, the number only represents the indices. The images below shown array of random values. Similar to the metropolis algorithm, we’ll use the metropolis criterion. We’ll first calculate the $\Delta E$ of the spin. If \(\Delta E < 0\), we’ll use the Metropolis criterion \(r < e^{\Delta E/k_BT}\) using the random values we’ve generated.
								<img src="/blog/2023//images/checkerboard_random_lattice_black.png" alt="" style="display: block; margin-left: auto; margin-right: auto; width: 40%;">
								<h3>References</h3>
								<p>
									[1] S. G. Brush, “History of the Lenz-Ising model,” Rev. Mod. Phys., vol. 39, no. 4, pp. 883–893, 1967, doi: 10.1103/RevModPhys.39.883.<br>
									[2] H. Gould and J. Tobochnik, Statistical and Thermal Physics: With Computer Applications. Princeton University Press, 2010.<br>
									[3] M. E. J. Newman and G. T. Barkema, Monte Carlo methods in statistical physics. Oxford University Press, 1999.<br>
									[4] N. Metropolis, A. W. Rosenbluth, M. N. Rosenbluth, A. H. Teller, and E. Teller, “Equation of state calculations by fast computing machines,” J. Chem. Phys., vol. 21, no. 6, pp. 1087–1092, Jun. 1953, doi: 10.1063/1.1699114.<br>
									[5] T. Preis, P. Virnau, W. Paul, and J. J. Schneider, “GPU accelerated Monte Carlo simulation of the 2D and 3D Ising model,” J. Comput. Phys., vol. 228, no. 12, pp. 4468–4477, 2009, doi: 10.1016/j.jcp.2009.03.018.
								</p>
								<hr />
							</section>
							
						</div>
					</div>
				<!-- Footer -->
				<footer id="footer">
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/kherzieandal/" target="_blank" class="icon brands alt fa-linkedin-in"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://github.com/kherzieandal" target="_blank" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
					</ul>
					<ul class="copyright">
						<li>&copy; 2023. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</footer>

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>
	</body>

</html>